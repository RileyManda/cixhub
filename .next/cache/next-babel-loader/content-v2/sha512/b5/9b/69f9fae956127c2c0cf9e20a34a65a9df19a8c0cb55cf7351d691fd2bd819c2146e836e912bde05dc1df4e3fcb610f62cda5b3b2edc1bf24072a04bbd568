{"ast":null,"code":"var __jsx = React.createElement;\nimport styled from 'styled-components';\nimport React, { useState, useRef } from 'react';\nconst StyledTooltip = styled.span.attrs(p => ({\n  bg: p.bg || 'dark',\n  delay: p.delay || 0.01\n}))`\n  position: fixed;\n  top: ${p => p.posRef.current.y}px;\n  left: ${p => p.posRef.current.x}px;\n  font-size: var(--fsize-2);\n  font-weight: 700;\n  letter-spacing: 0.02em;\n  background-color: rgba(var(--color-${p => p.bg}-rgb, 0, 0, 0), 0.9);\n  color: var(--color-${p => p.bg}-contrast, 255, 255, 255);\n  pointer-events: none;\n  padding: 7px 10px;\n  border-radius: 4px;\n  z-index: 99999;\n  display: inline-block;\n  white-space: nowrap;\n  opacity: ${p => p.show};\n  transition-property: transform, opacity !important;\n  transition-duration: 0.06s !important;\n  transition-timing-function: cubic-bezier(0, 0, 0.2, 1) !important;\n  transition-delay: ${p => p.show ? p.delay : 0.02}s !important;\n  transform-origin: ${p => position(p.placment).negate()};\n  transform: scale(${p => p.show ? 1 : 0.7});\n`;\n\nconst position = p => ({\n  current: p,\n\n  negate() {\n    if (this.current === 'left') return 'right';\n    if (this.current === 'right') return 'left';\n    if (this.current === 'top') return 'bottom';\n    if (this.current === 'bottom') return 'top';\n  },\n\n  isHorizontal() {\n    return this.current === 'left' || this.current === 'right';\n  },\n\n  isVertical() {\n    return this.current === 'top' || this.current === 'bottom';\n  }\n\n});\n\nconst point = () => ({\n  x: null,\n  y: null,\n\n  reset(p) {\n    this.x = p.x;\n    this.y = p.y;\n  },\n\n  restrictRect(rect) {\n    if (this.x < rect.l) this.x = rect.l;else if (this.x > rect.r) this.x = rect.r;\n    if (this.y < rect.t) this.y = rect.t;else if (this.y > rect.b) this.y = rect.b;\n  }\n\n});\n\nconst getPoint = (el, tt, placement, space) => {\n  let recurCount = 0;\n  const pt = point();\n  const bdys = {\n    l: space,\n    t: space,\n    r: document.body.clientWidth - (tt.clientWidth + space),\n    b: window.innerHeight - (tt.clientHeight + space)\n  };\n  const elRect = el.getBoundingClientRect();\n  return function recursive(placement) {\n    recurCount++;\n    const pos = position(placement);\n\n    switch (pos.current) {\n      case 'left':\n        pt.x = elRect.left - (tt.offsetWidth + space);\n        pt.y = elRect.top + (el.offsetHeight - tt.offsetHeight) / 2;\n        break;\n\n      case 'right':\n        pt.x = elRect.right + space;\n        pt.y = elRect.top + (el.offsetHeight - tt.offsetHeight) / 2;\n        break;\n\n      case 'top':\n        pt.x = elRect.left + (el.offsetWidth - tt.offsetWidth) / 2;\n        pt.y = elRect.top - (tt.offsetHeight + space);\n        break;\n\n      default:\n        pt.x = elRect.left + (el.offsetWidth - tt.offsetWidth) / 2;\n        pt.y = elRect.bottom + space;\n    }\n\n    if (recurCount < 3) if (pos.isHorizontal() && (pt.x < bdys.l || pt.x > bdys.r) || pos.isVertical() && (pt.y < bdys.t || pt.y > bdys.b)) {\n      pt.reset(recursive(pos.negate()));\n    } // restrict to rect boundary\n\n    pt.restrictRect(bdys);\n    return pt;\n  }(placement);\n};\n\nfunction CustomTooltip({\n  text,\n  placement = 'bottom',\n  space = 15,\n  children,\n  disabled = 0,\n  delay,\n  bg\n}) {\n  const {\n    0: show,\n    1: setShow\n  } = useState(0);\n  const posRef = useRef({\n    x: 0,\n    y: 0\n  });\n  const tooltipRef = useRef();\n\n  const handleMOver = e => {\n    setShow(1);\n    posRef.current = getPoint(e.currentTarget, tooltipRef.current, placement, space);\n  };\n\n  const handleMOut = () => setShow(0);\n\n  return __jsx(React.Fragment, null, disabled ? children : /*#__PURE__*/React.cloneElement(children, {\n    onMouseOver: handleMOver,\n    onMouseOut: handleMOut\n  }), disabled || __jsx(StyledTooltip, {\n    delay: delay,\n    bg: bg,\n    ref: tooltipRef,\n    posRef: posRef,\n    show: show\n  }, text));\n}\n\nexport default CustomTooltip;","map":null,"metadata":{},"sourceType":"module"}